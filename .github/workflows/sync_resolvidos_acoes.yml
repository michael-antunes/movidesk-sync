name: Sync Movidesk -> Ações de tickets resolvidos
on:
  schedule:
    - cron: "15 3 * * *"
  workflow_dispatch: {}
jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - run: sudo apt-get update && sudo apt-get install -y postgresql-client
      - env:
          NEON_DSN: ${{ secrets.NEON_DSN }}
        run: |
          psql "$NEON_DSN" -v ON_ERROR_STOP=1 <<'SQL'
          begin;
          create schema if not exists visualizacao_resolvidos;
          create table if not exists visualizacao_resolvidos.resolvidos_acoes (
            ticket_id integer primary key,
            acoes jsonb not null
          );
          commit;
          SQL
      - run: pip install requests psycopg2-binary
      - env:
          MOVIDESK_TOKEN: ${{ secrets.MOVIDESK_TOKEN }}
          NEON_DSN: ${{ secrets.NEON_DSN }}
          MOVIDESK_PAGE_SIZE: "500"
          MOVIDESK_THROTTLE: "0.25"
        run: |
          python - <<'PY'
          import os, time, json, datetime, requests, psycopg2, psycopg2.extras

          API_BASE = "https://api.movidesk.com/public/v1"
          TOKEN = os.getenv("MOVIDESK_TOKEN")
          DSN = os.getenv("NEON_DSN")
          TOP = int(os.getenv("MOVIDESK_PAGE_SIZE","500"))
          THROTTLE = float(os.getenv("MOVIDESK_THROTTLE","0.25"))

          http = requests.Session()
          http.headers.update({"Accept":"application/json"})

          def req(url, params, timeout=90):
              while True:
                  r = http.get(url, params=params, timeout=timeout)
                  if r.status_code in (429,503):
                      ra = r.headers.get("retry-after")
                      wait = int(ra) if ra and str(ra).isdigit() else 60
                      time.sleep(wait)
                      continue
                  if r.status_code == 404:
                      return []
                  r.raise_for_status()
                  return r.json() if r.text else []

          def as_utc(dt):
              if dt is None: return None
              if dt.tzinfo is None: return dt.replace(tzinfo=datetime.timezone.utc)
              return dt.astimezone(datetime.timezone.utc)

          def iso_z(dt):
              return dt.replace(microsecond=0).astimezone(datetime.timezone.utc).isoformat().replace("+00:00","Z")

          def get_since(conn):
              with conn.cursor() as cur:
                  cur.execute("select last_update from visualizacao_resolvidos.sync_control where name='tickets_resolvidos'")
                  row = cur.fetchone()
              base = as_utc(row[0]) if row and row[0] else datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(days=180)
              return base - datetime.timedelta(hours=4)

          def fetch_since(since_iso):
              url = f"{API_BASE}/tickets"
              skip = 0
              filtro = "(baseStatus eq 'Resolved' or baseStatus eq 'Closed' or baseStatus eq 'Canceled') and lastUpdate ge " + since_iso
              expand_opts = ["actions($top=2000)","actions"]
              ex_idx = 0
              items = []
              while True:
                  try:
                      page = req(url, {
                          "token": TOKEN,
                          "$select": "id,lastUpdate",
                          "$expand": expand_opts[ex_idx],
                          "$filter": filtro,
                          "$orderby": "lastUpdate asc",
                          "$top": TOP,
                          "$skip": skip
                      }) or []
                  except requests.HTTPError as e:
                      if e.response is not None and e.response.status_code == 400 and ex_idx < len(expand_opts)-1:
                          ex_idx += 1
                          continue
                      raise
                  if not page: break
                  items.extend(page)
                  if len(page) < TOP: break
                  skip += len(page)
                  time.sleep(THROTTLE)
              return items

          def fetch_by_ids(ids):
              out = []
              ids = [i for i in ids if str(i).isdigit()]
              for i in range(0, len(ids), 50):
                  batch = ids[i:i+50]
                  flt = "(" + " or ".join([f"id eq {int(x)}" for x in batch]) + ")"
                  page = req(f"{API_BASE}/tickets", {
                      "token": TOKEN,
                      "$select": "id",
                      "$expand": "actions($top=2000)",
                      "$filter": flt,
                      "$top": TOP,
                      "$skip": 0
                  }) or []
                  out.extend(page)
                  time.sleep(THROTTLE)
              return out

          def upsert_acoes(conn, tickets):
              rows = []
              for t in tickets:
                  tid = t.get("id")
                  if not str(tid).isdigit(): continue
                  acts = t.get("actions") or []
                  rows.append((int(tid), psycopg2.extras.Json(acts, dumps=lambda x: json.dumps(x, ensure_ascii=False))))
              if not rows: return 0
              with conn.cursor() as cur:
                  psycopg2.extras.execute_batch(cur, """
                      insert into visualizacao_resolvidos.resolvidos_acoes (ticket_id, acoes)
                      values (%s,%s)
                      on conflict (ticket_id) do update set acoes = excluded.acoes
                  """, rows, page_size=200)
              conn.commit()
              return len(rows)

          def missing_ids(conn):
              with conn.cursor() as cur:
                  cur.execute("""
                      select tr.ticket_id
                      from visualizacao_resolvidos.tickets_resolvidos tr
                      left join visualizacao_resolvidos.resolvidos_acoes ra using (ticket_id)
                      where ra.ticket_id is null
                      limit 1000
                  """)
                  return [r[0] for r in cur.fetchall()]

          def main():
              if not TOKEN or not DSN: raise SystemExit(1)
              with psycopg2.connect(DSN) as conn:
                  since = get_since(conn)
                  items = fetch_since(iso_z(since))
                  upsert_acoes(conn, items)
                  ids = missing_ids(conn)
                  if ids:
                      items2 = fetch_by_ids(ids)
                      upsert_acoes(conn, items2)

          if __name__ == "__main__":
              main()
          PY
